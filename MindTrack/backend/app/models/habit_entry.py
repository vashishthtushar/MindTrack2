import uuid
from datetime import date, datetime
from enum import Enum as PyEnum
from typing import Optional
from uuid import UUID
from sqlalchemy.dialects.postgresql import UUID as PG_UUID
from sqlalchemy.orm import relationship
from sqlalchemy.types import Enum as SAEnum
from pydantic import BaseModel, Field, field_validator

# /c:/Users/Sweta.Singh/Downloads/project/tts/new/backend/app/models/habit_entry.py


from sqlalchemy import (
    Column,
    String,
    Date,
    DateTime,
    ForeignKey,
    Float,
    Text,
)


from app.db.database import Base


class HabitStatus(PyEnum):
    DONE = "done"
    PARTIAL = "partial"
    MISSED = "missed"


def _uuid_column():
    """
    Use native PostgreSQL UUID type when available, otherwise fall back to String.
    """
    try:
        # If using PostgreSQL dialect this will work well
        return Column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    except Exception:
        return Column(String(36), primary_key=True, default=lambda: str(uuid.uuid4()))


class DailyHabitEntry(Base):
    """
    SQLAlchemy model for a daily habit entry.
    """
    __tablename__ = "habit_entries"

    # Primary key: UUID
    # Use PostgreSQL UUID type when available, otherwise string UUID
    entry_id = Column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)

    # Foreign key to users table (User.user_id)
    user_id = Column(PG_UUID(as_uuid=True), ForeignKey("users.user_id"), nullable=False)

    # Date the entry refers to (habit day)
    date = Column(Date, nullable=False)

    # Habit metadata
    habit_name = Column(String(255), nullable=False)
    target_value = Column(Float, nullable=True)

    # Constrained status
    status = Column(
        SAEnum(HabitStatus, name="habit_status", native_enum=False),
        nullable=False,
    )

    notes = Column(Text, nullable=True)

    # Simple numeric mood (could be scaled 1-10 or similar)
    mood = Column(Float, nullable=True)

    # Timestamp when entry was created/last updated
    timestamp = Column(DateTime, default=datetime.utcnow, nullable=False)

    # Relationship: many-to-one with User (assumes User has daily_habit_entries back_populates)
    user = relationship("User", back_populates="daily_habit_entries")

    def to_dict(self) -> dict:
        """
        Serialize the model into a JSON-serializable dict.
        Converts UUIDs and datetimes to strings.
        """
        return {
            "entry_id": str(self.entry_id) if self.entry_id is not None else None,
            "user_id": str(self.user_id) if self.user_id is not None else None,
            "date": self.date.isoformat() if isinstance(self.date, date) else None,
            "habit_name": self.habit_name,
            "target_value": self.target_value,
            "status": self.status.value if isinstance(self.status, HabitStatus) else self.status,
            "notes": self.notes,
            "mood": self.mood,
            "timestamp": self.timestamp.isoformat() if isinstance(self.timestamp, datetime) else None,
        }


# ----------------------
# Pydantic Schemas
# ----------------------

class HabitEntryBase(BaseModel):
    user_id: str = Field(..., description="User UUID owning this entry")
    entry_date: str = Field(..., description="Date of the habit entry (YYYY-MM-DD)")
    habit_name: str = Field(..., max_length=255)
    target_value: Optional[float] = None
    status: str
    notes: Optional[str] = None
    mood: Optional[float] = None


class HabitEntryCreate(HabitEntryBase):
    """
    Schema used when creating a new habit entry.
    entry_id and timestamp are generated by the backend.
    """
    pass


class HabitEntryResponse(HabitEntryBase):
    entry_id: UUID
    timestamp: datetime

    class Config:
        from_attributes = True